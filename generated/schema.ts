// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class VotingEscrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VotingEscrow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VotingEscrow must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VotingEscrow", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VotingEscrow | null {
    return changetype<VotingEscrow | null>(
      store.get_in_block("VotingEscrow", id)
    );
  }

  static load(id: string): VotingEscrow | null {
    return changetype<VotingEscrow | null>(store.get("VotingEscrow", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get stakedSupply(): BigDecimal | null {
    let value = this.get("stakedSupply");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set stakedSupply(value: BigDecimal | null) {
    if (!value) {
      this.unset("stakedSupply");
    } else {
      this.set("stakedSupply", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get locks(): VotingEscrowLockLoader {
    return new VotingEscrowLockLoader(
      "VotingEscrow",
      this.get("id")!.toString(),
      "locks"
    );
  }

  get omniLocks(): OmniVotingEscrowLockLoader {
    return new OmniVotingEscrowLockLoader(
      "VotingEscrow",
      this.get("id")!.toString(),
      "omniLocks"
    );
  }
}

export class OmniVotingEscrowLock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OmniVotingEscrowLock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OmniVotingEscrowLock must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OmniVotingEscrowLock", id.toString(), this);
    }
  }

  static loadInBlock(id: string): OmniVotingEscrowLock | null {
    return changetype<OmniVotingEscrowLock | null>(
      store.get_in_block("OmniVotingEscrowLock", id)
    );
  }

  static load(id: string): OmniVotingEscrowLock | null {
    return changetype<OmniVotingEscrowLock | null>(
      store.get("OmniVotingEscrowLock", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get localUser(): string {
    let value = this.get("localUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set localUser(value: string) {
    this.set("localUser", Value.fromString(value));
  }

  get remoteUser(): Bytes {
    let value = this.get("remoteUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set remoteUser(value: Bytes) {
    this.set("remoteUser", Value.fromBytes(value));
  }

  get dstChainId(): i32 {
    let value = this.get("dstChainId");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set dstChainId(value: i32) {
    this.set("dstChainId", Value.fromI32(value));
  }

  get bias(): BigDecimal {
    let value = this.get("bias");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set bias(value: BigDecimal) {
    this.set("bias", Value.fromBigDecimal(value));
  }

  get slope(): BigDecimal {
    let value = this.get("slope");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set slope(value: BigDecimal) {
    this.set("slope", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }

  get votingEscrowID(): string {
    let value = this.get("votingEscrowID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set votingEscrowID(value: string) {
    this.set("votingEscrowID", Value.fromString(value));
  }
}

export class VotingEscrowLock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VotingEscrowLock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VotingEscrowLock must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VotingEscrowLock", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VotingEscrowLock | null {
    return changetype<VotingEscrowLock | null>(
      store.get_in_block("VotingEscrowLock", id)
    );
  }

  static load(id: string): VotingEscrowLock | null {
    return changetype<VotingEscrowLock | null>(
      store.get("VotingEscrowLock", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get bias(): BigDecimal {
    let value = this.get("bias");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set bias(value: BigDecimal) {
    this.set("bias", Value.fromBigDecimal(value));
  }

  get slope(): BigDecimal {
    let value = this.get("slope");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set slope(value: BigDecimal) {
    this.set("slope", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }

  get unlockTime(): BigInt {
    let value = this.get("unlockTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set unlockTime(value: BigInt) {
    this.set("unlockTime", Value.fromBigInt(value));
  }

  get lockedBalance(): BigDecimal {
    let value = this.get("lockedBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set lockedBalance(value: BigDecimal) {
    this.set("lockedBalance", Value.fromBigDecimal(value));
  }

  get votingEscrowID(): string {
    let value = this.get("votingEscrowID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set votingEscrowID(value: string) {
    this.set("votingEscrowID", Value.fromString(value));
  }

  get updatedAt(): i32 {
    let value = this.get("updatedAt");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set updatedAt(value: i32) {
    this.set("updatedAt", Value.fromI32(value));
  }
}

export class LockSnapshot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LockSnapshot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LockSnapshot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LockSnapshot", id.toString(), this);
    }
  }

  static loadInBlock(id: string): LockSnapshot | null {
    return changetype<LockSnapshot | null>(
      store.get_in_block("LockSnapshot", id)
    );
  }

  static load(id: string): LockSnapshot | null {
    return changetype<LockSnapshot | null>(store.get("LockSnapshot", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get bias(): BigDecimal {
    let value = this.get("bias");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set bias(value: BigDecimal) {
    this.set("bias", Value.fromBigDecimal(value));
  }

  get slope(): BigDecimal {
    let value = this.get("slope");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set slope(value: BigDecimal) {
    this.set("slope", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class GaugeFactory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GaugeFactory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GaugeFactory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GaugeFactory", id.toString(), this);
    }
  }

  static loadInBlock(id: string): GaugeFactory | null {
    return changetype<GaugeFactory | null>(
      store.get_in_block("GaugeFactory", id)
    );
  }

  static load(id: string): GaugeFactory | null {
    return changetype<GaugeFactory | null>(store.get("GaugeFactory", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get numGauges(): i32 {
    let value = this.get("numGauges");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set numGauges(value: i32) {
    this.set("numGauges", Value.fromI32(value));
  }

  get gauges(): LiquidityGaugeLoader {
    return new LiquidityGaugeLoader(
      "GaugeFactory",
      this.get("id")!.toString(),
      "gauges"
    );
  }
}

export class LiquidityGauge extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LiquidityGauge entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LiquidityGauge must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LiquidityGauge", id.toString(), this);
    }
  }

  static loadInBlock(id: string): LiquidityGauge | null {
    return changetype<LiquidityGauge | null>(
      store.get_in_block("LiquidityGauge", id)
    );
  }

  static load(id: string): LiquidityGauge | null {
    return changetype<LiquidityGauge | null>(store.get("LiquidityGauge", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get gauge(): string | null {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set gauge(value: string | null) {
    if (!value) {
      this.unset("gauge");
    } else {
      this.set("gauge", Value.fromString(<string>value));
    }
  }

  get pool(): string | null {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set pool(value: string | null) {
    if (!value) {
      this.unset("pool");
    } else {
      this.set("pool", Value.fromString(<string>value));
    }
  }

  get poolAddress(): Bytes {
    let value = this.get("poolAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set poolAddress(value: Bytes) {
    this.set("poolAddress", Value.fromBytes(value));
  }

  get poolId(): Bytes | null {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set poolId(value: Bytes | null) {
    if (!value) {
      this.unset("poolId");
    } else {
      this.set("poolId", Value.fromBytes(<Bytes>value));
    }
  }

  get isKilled(): boolean {
    let value = this.get("isKilled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isKilled(value: boolean) {
    this.set("isKilled", Value.fromBoolean(value));
  }

  get isPreferentialGauge(): boolean {
    let value = this.get("isPreferentialGauge");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isPreferentialGauge(value: boolean) {
    this.set("isPreferentialGauge", Value.fromBoolean(value));
  }

  get relativeWeightCap(): BigDecimal | null {
    let value = this.get("relativeWeightCap");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set relativeWeightCap(value: BigDecimal | null) {
    if (!value) {
      this.unset("relativeWeightCap");
    } else {
      this.set("relativeWeightCap", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get streamer(): Bytes | null {
    let value = this.get("streamer");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set streamer(value: Bytes | null) {
    if (!value) {
      this.unset("streamer");
    } else {
      this.set("streamer", Value.fromBytes(<Bytes>value));
    }
  }

  get factory(): string {
    let value = this.get("factory");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set factory(value: string) {
    this.set("factory", Value.fromString(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get rewardTokensList(): Array<Bytes> | null {
    let value = this.get("rewardTokensList");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytesArray();
    }
  }

  set rewardTokensList(value: Array<Bytes> | null) {
    if (!value) {
      this.unset("rewardTokensList");
    } else {
      this.set("rewardTokensList", Value.fromBytesArray(<Array<Bytes>>value));
    }
  }

  get shares(): GaugeShareLoader {
    return new GaugeShareLoader(
      "LiquidityGauge",
      this.get("id")!.toString(),
      "shares"
    );
  }

  get tokens(): RewardTokenLoader {
    return new RewardTokenLoader(
      "LiquidityGauge",
      this.get("id")!.toString(),
      "tokens"
    );
  }
}

export class RootGauge extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RootGauge entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RootGauge must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RootGauge", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RootGauge | null {
    return changetype<RootGauge | null>(store.get_in_block("RootGauge", id));
  }

  static load(id: string): RootGauge | null {
    return changetype<RootGauge | null>(store.get("RootGauge", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get chain(): string {
    let value = this.get("chain");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set chain(value: string) {
    this.set("chain", Value.fromString(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get gauge(): string | null {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set gauge(value: string | null) {
    if (!value) {
      this.unset("gauge");
    } else {
      this.set("gauge", Value.fromString(<string>value));
    }
  }

  get isKilled(): boolean {
    let value = this.get("isKilled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isKilled(value: boolean) {
    this.set("isKilled", Value.fromBoolean(value));
  }

  get relativeWeightCap(): BigDecimal | null {
    let value = this.get("relativeWeightCap");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set relativeWeightCap(value: BigDecimal | null) {
    if (!value) {
      this.unset("relativeWeightCap");
    } else {
      this.set("relativeWeightCap", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get factory(): string {
    let value = this.get("factory");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set factory(value: string) {
    this.set("factory", Value.fromString(value));
  }
}

export class SingleRecipientGauge extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SingleRecipientGauge entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SingleRecipientGauge must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SingleRecipientGauge", id.toString(), this);
    }
  }

  static loadInBlock(id: string): SingleRecipientGauge | null {
    return changetype<SingleRecipientGauge | null>(
      store.get_in_block("SingleRecipientGauge", id)
    );
  }

  static load(id: string): SingleRecipientGauge | null {
    return changetype<SingleRecipientGauge | null>(
      store.get("SingleRecipientGauge", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get gauge(): string | null {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set gauge(value: string | null) {
    if (!value) {
      this.unset("gauge");
    } else {
      this.set("gauge", Value.fromString(<string>value));
    }
  }

  get isKilled(): boolean {
    let value = this.get("isKilled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isKilled(value: boolean) {
    this.set("isKilled", Value.fromBoolean(value));
  }

  get relativeWeightCap(): BigDecimal | null {
    let value = this.get("relativeWeightCap");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set relativeWeightCap(value: BigDecimal | null) {
    if (!value) {
      this.unset("relativeWeightCap");
    } else {
      this.set("relativeWeightCap", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get factory(): string {
    let value = this.get("factory");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set factory(value: string) {
    this.set("factory", Value.fromString(value));
  }
}

export class Gauge extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Gauge entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Gauge must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Gauge", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Gauge | null {
    return changetype<Gauge | null>(store.get_in_block("Gauge", id));
  }

  static load(id: string): Gauge | null {
    return changetype<Gauge | null>(store.get("Gauge", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get type(): string {
    let value = this.get("type");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }

  get addedTimestamp(): i32 {
    let value = this.get("addedTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set addedTimestamp(value: i32) {
    this.set("addedTimestamp", Value.fromI32(value));
  }

  get liquidityGauge(): string | null {
    let value = this.get("liquidityGauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set liquidityGauge(value: string | null) {
    if (!value) {
      this.unset("liquidityGauge");
    } else {
      this.set("liquidityGauge", Value.fromString(<string>value));
    }
  }

  get rootGauge(): string | null {
    let value = this.get("rootGauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set rootGauge(value: string | null) {
    if (!value) {
      this.unset("rootGauge");
    } else {
      this.set("rootGauge", Value.fromString(<string>value));
    }
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Pool", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Pool | null {
    return changetype<Pool | null>(store.get_in_block("Pool", id));
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolId(): Bytes | null {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set poolId(value: Bytes | null) {
    if (!value) {
      this.unset("poolId");
    } else {
      this.set("poolId", Value.fromBytes(<Bytes>value));
    }
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get preferentialGauge(): string | null {
    let value = this.get("preferentialGauge");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set preferentialGauge(value: string | null) {
    if (!value) {
      this.unset("preferentialGauge");
    } else {
      this.set("preferentialGauge", Value.fromString(<string>value));
    }
  }

  get gaugesList(): Array<Bytes> {
    let value = this.get("gaugesList");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytesArray();
    }
  }

  set gaugesList(value: Array<Bytes>) {
    this.set("gaugesList", Value.fromBytesArray(value));
  }

  get gauges(): LiquidityGaugeLoader {
    return new LiquidityGaugeLoader(
      "Pool",
      this.get("id")!.toString(),
      "gauges"
    );
  }
}

export class RewardToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RewardToken", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RewardToken | null {
    return changetype<RewardToken | null>(
      store.get_in_block("RewardToken", id)
    );
  }

  static load(id: string): RewardToken | null {
    return changetype<RewardToken | null>(store.get("RewardToken", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get gauge(): string {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set gauge(value: string) {
    this.set("gauge", Value.fromString(value));
  }

  get rate(): BigDecimal | null {
    let value = this.get("rate");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set rate(value: BigDecimal | null) {
    if (!value) {
      this.unset("rate");
    } else {
      this.set("rate", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get periodFinish(): BigInt | null {
    let value = this.get("periodFinish");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set periodFinish(value: BigInt | null) {
    if (!value) {
      this.unset("periodFinish");
    } else {
      this.set("periodFinish", Value.fromBigInt(<BigInt>value));
    }
  }

  get totalDeposited(): BigDecimal {
    let value = this.get("totalDeposited");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set totalDeposited(value: BigDecimal) {
    this.set("totalDeposited", Value.fromBigDecimal(value));
  }
}

export class GaugeShare extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GaugeShare entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GaugeShare must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GaugeShare", id.toString(), this);
    }
  }

  static loadInBlock(id: string): GaugeShare | null {
    return changetype<GaugeShare | null>(store.get_in_block("GaugeShare", id));
  }

  static load(id: string): GaugeShare | null {
    return changetype<GaugeShare | null>(store.get("GaugeShare", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get gauge(): string {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set gauge(value: string) {
    this.set("gauge", Value.fromString(value));
  }

  get balance(): BigDecimal {
    let value = this.get("balance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set balance(value: BigDecimal) {
    this.set("balance", Value.fromBigDecimal(value));
  }
}

export class GaugeType extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GaugeType entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GaugeType must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GaugeType", id.toString(), this);
    }
  }

  static loadInBlock(id: string): GaugeType | null {
    return changetype<GaugeType | null>(store.get_in_block("GaugeType", id));
  }

  static load(id: string): GaugeType | null {
    return changetype<GaugeType | null>(store.get("GaugeType", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }
}

export class GaugeVote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GaugeVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GaugeVote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GaugeVote", id.toString(), this);
    }
  }

  static loadInBlock(id: string): GaugeVote | null {
    return changetype<GaugeVote | null>(store.get_in_block("GaugeVote", id));
  }

  static load(id: string): GaugeVote | null {
    return changetype<GaugeVote | null>(store.get("GaugeVote", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get gauge(): string {
    let value = this.get("gauge");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set gauge(value: string) {
    this.set("gauge", Value.fromString(value));
  }

  get weight(): BigDecimal | null {
    let value = this.get("weight");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set weight(value: BigDecimal | null) {
    if (!value) {
      this.unset("weight");
    } else {
      this.set("weight", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get timestamp(): BigInt | null {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt | null) {
    if (!value) {
      this.unset("timestamp");
    } else {
      this.set("timestamp", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type User must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toString(), this);
    }
  }

  static loadInBlock(id: string): User | null {
    return changetype<User | null>(store.get_in_block("User", id));
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get gaugeVotes(): GaugeVoteLoader {
    return new GaugeVoteLoader(
      "User",
      this.get("id")!.toString(),
      "gaugeVotes"
    );
  }

  get gaugeShares(): GaugeShareLoader {
    return new GaugeShareLoader(
      "User",
      this.get("id")!.toString(),
      "gaugeShares"
    );
  }

  get votingLocks(): VotingEscrowLockLoader {
    return new VotingEscrowLockLoader(
      "User",
      this.get("id")!.toString(),
      "votingLocks"
    );
  }

  get omniVotingLocks(): OmniVotingEscrowLockLoader {
    return new OmniVotingEscrowLockLoader(
      "User",
      this.get("id")!.toString(),
      "omniVotingLocks"
    );
  }
}

export class VotingEscrowLockLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VotingEscrowLock[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VotingEscrowLock[]>(value);
  }
}

export class OmniVotingEscrowLockLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): OmniVotingEscrowLock[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<OmniVotingEscrowLock[]>(value);
  }
}

export class LiquidityGaugeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): LiquidityGauge[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<LiquidityGauge[]>(value);
  }
}

export class GaugeShareLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GaugeShare[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GaugeShare[]>(value);
  }
}

export class RewardTokenLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RewardToken[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RewardToken[]>(value);
  }
}

export class GaugeVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): GaugeVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<GaugeVote[]>(value);
  }
}
